<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>ich liebe dich – Linien formen Schrift</title>
  <style>
    html,body{margin:0;height:100%;background:#0b0f14;overflow:hidden;}
    canvas{display:block;}
    .hint{position:fixed;left:12px;bottom:12px;color:#aab;opacity:.85;font:12px/1.2 system-ui}
  </style>
</head>
<body>
  <div class="hint">[R] neu • Klick: Palette • Linien formen “ich liebe dich” → halten → lösen (Loop ~30s)</div>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/p5.min.js"></script>
  <script>
    // ---------------- Parameter ----------------
    let agents = [];
    let fieldScale = 0.0025;     // Dichte/Detailgrad des Flowfields (frei)
    let stepsPerFrame = 4;       // Zeichen-Geschwindigkeit
    let maxAge = 600;            // Lebensdauer der Partikel
    let palettes = [
      ["#00F5D4","#00BBF9","#6A00F4","#F20089","#FF5964","#FFE45E"],
      ["#00FFA3","#19A1F7","#7C3AED","#F472B6","#FF7A00","#FFD60A"],
      ["#64DFDF","#6930C3","#80FFDB","#FF4D6D","#B5179E","#4CC9F0"]
    ];
    let paletteIdx = 0;
    let bgCol = "#0b0f14";
    let seed;

    // Schrift-Feld
    const PHRASE = "ich liebe dich";
    let g;                 // offscreen p5.Graphics
    let textBounds;        // ungefähre Bounding Box (für Spawn/Skalierung)
    let fontSizeFactor = 0.26;  // Anteil der kurzen Kante

    // Sequenzzeiten (gesamt ~30s)
    const TOTAL_MS = 30000;
    const BUILD_FRAC = 0.42;  // Anteil “Formieren”
    const HOLD_FRAC  = 0.18;  // Anteil “Halten”
    const DISS_FRAC  = 1 - BUILD_FRAC - HOLD_FRAC; // “Auflösen”

    function setup(){
      createCanvas(window.innerWidth, window.innerHeight);
      pixelDensity(1);
      noFill();
      g = createGraphics(window.innerWidth, window.innerHeight);
      g.pixelDensity(1);
      resetArt(true);
    }

    function windowResized(){
      resizeCanvas(window.innerWidth, window.innerHeight);
      g = createGraphics(window.innerWidth, window.innerHeight);
      g.pixelDensity(1);
      resetArt(true);
    }

    function keyPressed(){
      if(key === 'r' || key === 'R') resetArt(true);
      if(key === 's' || key === 'S') saveCanvas("generative", "png");
    }

    function mousePressed(){
      paletteIdx = (paletteIdx + 1) % palettes.length;
      resetArt(false);
    }

    function resetArt(clearBG){
      seed = floor(random(1e9));
      randomSeed(seed); noiseSeed(seed);
      if(clearBG){ background(bgCol); }
      blendMode(ADD);
      agents = [];
      const count = floor((width*height) / 1200);
      for(let i=0;i<count;i++){
        agents.push(makeAgent());
      }
      buildTextField(); // Offscreen-Schrift neu rendern
    }

    // ---- Offscreen-Textfeld aufbauen (für Vektoranziehung) ----
    function buildTextField(){
      g.clear();
      const minSide = min(width, height);
      const fs = max(28, floor(minSide * fontSizeFactor));
      g.push();
      g.textAlign(CENTER, CENTER);
      g.textSize(fs);
      g.textStyle(BOLD);
      g.noStroke();
      g.fill(255);
      // leichte Unschärfe-Schicht für stabilere Gradienten
      g.text(PHRASE, width/2, height/2);
      g.pop();
      g.loadPixels();
    }

    // Alpha an Position (0–255)
    function alphaAt(x, y){
      x = constrain(floor(x), 0, g.width-1);
      y = constrain(floor(y), 0, g.height-1);
      const idx = (y * g.width + x) * 4 + 3;
      return g.pixels[idx] || 0;
    }

    // Gradientenfeld (zeigt in Richtung “mehr Text”)
    function textGradient(x, y){
      // zentrale Differenzen (sanft)
      const s = 2; // Sample-Abstand in Pixeln
      const ax1 = alphaAt(x+s, y), ax0 = alphaAt(x-s, y);
      const ay1 = alphaAt(x, y+s), ay0 = alphaAt(x, y-s);
      const gx = (ax1 - ax0) * 0.5; // -255..255
      const gy = (ay1 - ay0) * 0.5;
      const v = createVector(gx, gy);
      if(v.magSq()>0) v.normalize();
      return v;
    }

    // Feldgewicht 0..1 in Abhängigkeit der Zeit (ease)
    function sequenceWeights(){
      const t = (millis() % TOTAL_MS) / TOTAL_MS; // 0..1
      if(t < BUILD_FRAC){
        const k = t / BUILD_FRAC;             // 0..1
        return easeInOut(k);                  // Text-Einfluss wächst
      }else if(t < BUILD_FRAC + HOLD_FRAC){
        return 1;                             // maximaler Texteffekt (halten)
      }else{
        const k = (t - BUILD_FRAC - HOLD_FRAC) / DISS_FRAC; // 0..1
        return 1 - easeInOut(k);              // Text-Einfluss lässt nach
      }
    }

    // sanfte Ease-Funktion
    function easeInOut(x){ return x<.5 ? 2*x*x : 1 - pow(-2*x+2, 2)/2; }

    function makeAgent(){
      const p = createVector(random(width), random(height));
      const hue = color(random(palettes[paletteIdx]));
      const w = random(0.6, 1.6);
      const jitter = random(0.002, 0.01);
      return {
        p, prev:p.copy(),
        age: 0,
        speed: random(0.5, 1.7),
        w,
        c: hue,
        jitter
      };
    }

    function flow(x, y, t){
      const a = noise(x*fieldScale, y*fieldScale, t)*TAU*2;
      return a;
    }

    function draw(){
      for(let s=0; s<stepsPerFrame; s++){
        stepAgents();
      }
      // leichte Vignette / Nachglühen
      noStroke();
      fill(11,15,20, 6);
      rect(0,0,width,height);
    }

    function stepAgents(){
      const t = frameCount * 0.003;
      const kText = sequenceWeights(); // 0..1

      for(let i=0;i<agents.length;i++){
        const a = agents[i];

        // --- Richtungsvektoren ---
        // 1) freies Flowfeld
        const ang = flow(a.p.x, a.p.y, t) + (noise(a.p.x*a.jitter, a.p.y*a.jitter)-0.5)*0.6;
        const vFree = p5.Vector.fromAngle(ang).mult(a.speed);

        // 2) Text-Gradient: zieht in Bereiche hoher Schrift-Alpha
        const grad = textGradient(a.p.x, a.p.y); // normiert
        // Stärke abhängig davon, wie nah wir am Text sind
        const A = alphaAt(a.p.x, a.p.y)/255; // 0..1
        // sanfte Anhebung nahe der Buchstaben
        const pull = map(A, 0, 1, 0.4, 1.8) * a.speed * 1.0;
        const vText = grad.mult(pull);

        // Mischung: zuerst frei, dann zunehmend Schrift
        const v = p5.Vector.lerp(vFree, vText, kText);

        // Positionsupdate
        a.prev.set(a.p);
        a.p.add(v);

        // Alter / Respawn
        a.age++;
        if(a.age > maxAge || a.p.x<-12 || a.p.x>width+12 || a.p.y<-12 || a.p.y>height+12){
          agents[i] = makeAgent();
          continue;
        }

        // Zeichnen
        const nearText = alphaAt(a.p.x, a.p.y)/255; // Nähe zur Schrift
        const brightnessBoost = lerp(0, 80, pow(nearText, 0.8) * kText); // heller auf den Buchstaben
        const alphaDyn = map(noise(a.p.x*0.005, a.p.y*0.005, t),0,1,40,120) + brightnessBoost;

        strokeWeight( a.w * (1 + 0.6*nearText*kText) );
        stroke(red(a.c), green(a.c), blue(a.c), constrain(alphaDyn, 30, 200));
        line(a.prev.x, a.prev.y, a.p.x, a.p.y);

        // gelegentlich feiner Punkt
        if(a.age % 23 === 0){
          strokeWeight(a.w*0.55);
          point(a.p.x, a.p.y);
        }
      }

      // optional: sehr dezenter “Glow” um die Phrase (nur in Build/Hold sichtbar)
      if(sequenceWeights()>0.25){
        push();
        blendMode(ADD);
        noFill();
        stroke(255, 18);
        strokeWeight(1);
        // weiche Konturen skizzieren, indem wir grob die Alpha-Kanten abfahren
        // (sparsam: nur wenige zufällige Samples)
        for(let s=0; s<60; s++){
          const x = random(width), y = random(height);
          if(alphaAt(x,y)>180){
            const gdir = textGradient(x,y);
            line(x, y, x + gdir.x*8, y + gdir.y*8);
          }
        }
        pop();
      }
    }
  </script>
</body>
</html>
