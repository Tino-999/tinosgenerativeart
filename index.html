<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>ich liebe dich – romantische Partikel</title>
<style>
  :root{
    --bg1:#0a0b10;
    --bg2:#121320;
  }
  html,body{height:100%;margin:0;overflow:hidden;background:radial-gradient(1200px 900px at 70% 20%,#1a1b2a 0%,var(--bg2) 60%,var(--bg1) 100%);}
  canvas{display:block;width:100%;height:100%;}
  .hint{
    position:fixed;left:50%;bottom:12px;transform:translateX(-50%);
    font:12px/1.2 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    letter-spacing:.08em;text-transform:uppercase;color:#cfd6ffb0;pointer-events:none;user-select:none
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="hint">Tippen: kleine Herzen • 30s Loop</div>
<script>
(()=>{
// ---------------- Config ----------------
const PHRASE = "ich liebe dich";
const TOTAL_DURATION = 30_000; // ~30s komplett
const APPEAR_MS = 900, HOLD_MS = 350, BLOOM_MS = 1000, FADE_MS = 1400, GAP_MS = 120;
const FONT_FIT = 0.30;      // Anteile der kleineren Kante
const GRID_STEP_BASE = 6;   // Sampling-Dichte (kleiner = dichter)
const PARTICLE_SIZE = 1.4;  // feiner Punkt
const HEART_RATIO = 0.35;   // Anteil Herz-Partikel
const TRAIL = 0.07;         // Hintergrundausblendung
const GLOW = true;          // Additiver Glanz
const BOKEH_COUNT = 28;     // romantische Bokeh-Lichter
const BOKEH_MAX_R = 110;

// ---------------- Canvas ----------------
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
function fit(){
  const dpr = devicePixelRatio||1;
  canvas.width = Math.floor(innerWidth*dpr);
  canvas.height= Math.floor(innerHeight*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener('resize', fit,{passive:true});
fit();

// ---------------- Bokeh Hintergrund ----------------
const bokeh = Array.from({length:BOKEH_COUNT},()=>({
  x: Math.random()*innerWidth,
  y: Math.random()*innerHeight,
  r: 10+Math.random()*BOKEH_MAX_R,
  spd: 0.02+Math.random()*0.06,
  p: Math.random()*Math.PI*2,
  a: 0.04+Math.random()*0.08
}));

function drawBokeh(t){
  for(const b of bokeh){
    b.p += b.spd*0.002*t;
    const ox = Math.cos(b.p)*12, oy = Math.sin(b.p*0.8)*10;
    const x = b.x+ox, y = b.y+oy;
    const g = ctx.createRadialGradient(x,y,0,x,y,b.r);
    g.addColorStop(0, `hsla(${(baseHue+12)%360},70%,70%,${b.a})`);
    g.addColorStop(1, `hsla(${(baseHue+12)%360},70%,70%,0)`);
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(x,y,b.r,0,Math.PI*2); ctx.fill();
  }
  ctx.globalCompositeOperation = 'source-over';
}

// ---------------- Offscreen Text Sampling ----------------
const off = document.createElement('canvas');
const ox = off.getContext('2d');
function samplePoints(letter){
  off.width = innerWidth; off.height = innerHeight;
  const minSide = Math.min(innerWidth, innerHeight);
  const fontSize = Math.max(30, Math.floor(minSide*FONT_FIT));
  ox.clearRect(0,0,off.width,off.height);
  ox.fillStyle='#fff';
  ox.textAlign='center';
  ox.textBaseline='middle';
  ox.font = `800 ${fontSize}px/1.05 system-ui, -apple-system, Roboto, Helvetica, Arial, sans-serif`;
  // leicht geschwungenes Kerning: sanfter Schatten
  ox.shadowColor='rgba(255,255,255,.32)'; ox.shadowBlur=fontSize*0.05;
  ox.fillText(letter, off.width/2, off.height/2);

  const step = Math.max(3, Math.floor(GRID_STEP_BASE*(minSide/800)));
  const data = ox.getImageData(0,0,off.width,off.height).data;
  const pts=[];
  const x0=Math.floor(off.width*0.08), x1=Math.floor(off.width*0.92);
  const y0=Math.floor(off.height*0.15), y1=Math.floor(off.height*0.85);
  for(let y=y0; y<y1; y+=step){
    for(let x=x0; x<x1; x+=step){
      const i=(y*off.width+x)*4;
      if(data[i+3]>140){
        const jx=(Math.random()-.5)*step*.55;
        const jy=(Math.random()-.5)*step*.55;
        pts.push({x:x+jx,y:y+jy});
      }
    }
  }
  return pts;
}

// ---------------- Hilfsfunktionen ----------------
const easeOutCubic=x=>1-Math.pow(1-x,3);
const easeInOutQuad=x=>x<.5?2*x*x:1-Math.pow(-2*x+2,2)/2;

// romantische Palette um ein Grund-Hue herum
let baseHue = 330; // rosé
function hue(i,n){
  return (baseHue + (i/n)*60 + Math.sin(i*0.017)*8)%360;
}

// Herz zeichnen (klein & simpel)
function drawHeart(x,y,r){
  ctx.beginPath();
  // Parametrische Herzform (Bezier)
  const s=r;
  ctx.moveTo(x, y - s*0.35);
  ctx.bezierCurveTo(x - s, y - s*0.9, x - s*1.3, y + s*0.2, x, y + s*0.8);
  ctx.bezierCurveTo(x + s*1.3, y + s*0.2, x + s, y - s*0.9, x, y - s*0.35);
  ctx.closePath();
  ctx.fill();
}

// ---------------- Partikel/Burst ----------------
class Burst{
  constructor(letter, t0){
    this.letter=letter;
    this.t0=t0;
    this.points = letter===' '?[]:samplePoints(letter);
    this.n=this.points.length||1;
    this.parts=this.points.map((p,i)=>{
      // weich öffnendes „Bloom“ statt knalligem Platzen
      const theta = Math.random()*Math.PI*2;
      const spiral = 0.8+Math.random()*1.2;
      const isHeart = Math.random()<HEART_RATIO;
      const w = isHeart ? PARTICLE_SIZE*2.2 : PARTICLE_SIZE*(0.9+Math.random()*0.7);
      return {
        ox:p.x, oy:p.y,
        x:p.x, y:p.y,
        th:theta, sp:spiral,
        w, isHeart,
        h:hue(i,this.n),
        id:i,
        z: 0.7+Math.random()*0.6 // leichte Größen/Energie-Variation
      };
    });
  }
  phase(now){
    const dt=now-this.t0;
    if(dt<APPEAR_MS) return 'appear';
    if(dt<APPEAR_MS+HOLD_MS) return 'hold';
    if(dt<APPEAR_MS+HOLD_MS+BLOOM_MS) return 'bloom';
    if(dt<APPEAR_MS+HOLD_MS+BLOOM_MS+FADE_MS) return 'fade';
    return 'done';
  }
  draw(now){
    const dt=now-this.t0;
    const ph=this.phase(now);

    if(ph==='appear'||ph==='hold'){
      const k = ph==='appear' ? easeOutCubic(Math.min(1, dt/APPEAR_MS)) : 1;
      for(const p of this.parts){
        const alpha = 0.65*k;
        ctx.globalAlpha = alpha;
        if (p.isHeart){
          ctx.fillStyle = `hsla(${p.h},85%,70%,${alpha})`;
          drawHeart(p.x,p.y,p.w*1.2);
        }else{
          ctx.fillStyle = `hsla(${p.h},90%,75%,${alpha})`;
          ctx.beginPath(); ctx.arc(p.x,p.y,p.w*.7,0,Math.PI*2); ctx.fill();
          // feine Linienfaser
          ctx.globalAlpha = alpha*0.35;
          ctx.lineWidth = 0.45;
          ctx.beginPath();
          ctx.moveTo(p.x,p.y);
          const len=2+Math.sin((now*0.002)+p.id)*1.4;
          ctx.lineTo(p.x+Math.cos(p.id*0.29)*len,p.y+Math.sin(p.id*0.29)*len);
          ctx.strokeStyle=`hsla(${p.h},70%,65%,${alpha*.35})`;
          ctx.stroke();
        }
      }
    }else if(ph==='bloom'||ph==='fade'){
      // sanftes Aufblühen + davonwehen auf eleganter Kurve
      const tStart=APPEAR_MS+HOLD_MS;
      const tBloom=Math.max(0,Math.min(1,(dt - tStart)/BLOOM_MS));
      const kBloom=easeInOutQuad(tBloom);
      const tFade=Math.max(0,Math.min(1,(dt - (tStart+BLOOM_MS))/FADE_MS));
      const kFade= tFade;

      for(const p of this.parts){
        const swirl = 18*p.sp*(kBloom+0.3);
        const r = 38*p.z*kBloom + 120*p.z*kFade;
        const vx = Math.cos(p.th+swirl*0.02)*r + Math.sin((now*0.0013)+p.id*0.7)*8*kBloom;
        const vy = Math.sin(p.th+swirl*0.02)*r + Math.cos((now*0.0011)+p.id*0.6)*7*kBloom - 16*kFade; // leichter Auftrieb
        const x = p.ox + vx, y = p.oy + vy;

        const alpha = (1-kFade)*0.9*(1-0.15*Math.random());
        ctx.globalAlpha = Math.max(0,alpha);
        if (p.isHeart){
          ctx.fillStyle = `hsla(${p.h},90%,70%,${alpha})`;
          drawHeart(x,y,p.w*(1+0.7*kBloom));
        }else{
          ctx.fillStyle = `hsla(${p.h},95%,72%,${alpha})`;
          ctx.beginPath(); ctx.arc(x,y,p.w*(1+0.8*kBloom),0,Math.PI*2); ctx.fill();
        }

        // feiner Schweif
        ctx.globalAlpha = Math.max(0, alpha*0.35);
        ctx.lineWidth = 0.4;
        ctx.beginPath(); ctx.moveTo(p.ox,p.oy); ctx.lineTo(x,y);
        ctx.strokeStyle = `hsla(${p.h},70%,65%,${alpha*0.5})`; ctx.stroke();
      }
    }
    ctx.globalAlpha=1;
  }
}

// ---------------- Sequencer ----------------
const letters = PHRASE.split('');
const rawPer = APPEAR_MS+HOLD_MS+BLOOM_MS+FADE_MS+GAP_MS;
const scale = (TOTAL_DURATION/Math.max(1,letters.length))/rawPer;
const APPEAR = (APPEAR_MS*scale)|0, HOLD=(HOLD_MS*scale)|0, BLOOM=(BLOOM_MS*scale)|0, FADE=(FADE_MS*scale)|0, GAP=(GAP_MS*scale)|0;
const PER = APPEAR+HOLD+BLOOM+FADE+GAP;

let idx=0;
let current = new Burst(letters[idx], performance.now());
let lastSwitch = current.t0;

// ---------------- Loop ----------------
function loop(now){
  // zarte Abdunklung für Trails
  ctx.globalCompositeOperation='source-over';
  ctx.fillStyle=`rgba(8,9,14,${TRAIL})`;
  ctx.fillRect(0,0,innerWidth,innerHeight);

  // langsam driftender Hintergrundfarbton
  baseHue = (baseHue + 0.02) % 360;

  // Bokeh
  drawBokeh(now*0.06);

  // Glanzmodus
  if(GLOW) ctx.globalCompositeOperation='lighter';
  current.draw(now);
  ctx.globalCompositeOperation='source-over';

  // Sequenzwechsel
  const elapsed = now - lastSwitch;
  if (elapsed>=PER || current.phase(now)==='done'){
    idx = (idx+1)%letters.length;
    lastSwitch = now;
    current = new Burst(letters[idx], now);
  }
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// ---------------- Interaktion: Tippen = kleine aufsteigende Herzen ----------------
addEventListener('pointerdown', (e)=>{
  const x=e.clientX, y=e.clientY;
  const n=20+Math.floor(Math.random()*20);
  for(let i=0;i<n;i++){
    const h = (baseHue + 8 + Math.random()*30)%360;
    const r = 3+Math.random()*6;
    const life = 900+Math.random()*900;
    const ang = -Math.PI/2 + (Math.random()-0.5)*0.9;
    const sp = 0.15+Math.random()*0.35;
    const t0 = performance.now();
    const anim = ()=>{
      const now=performance.now();
      const k = Math.min(1,(now-t0)/life);
      const ease = easeOutCubic(k);
      ctx.globalCompositeOperation='lighter';
      ctx.globalAlpha = (1-k)*0.9;
      ctx.fillStyle = `hsla(${h},85%,70%,${(1-k)*0.9})`;
      const dx = Math.cos(ang)*sp*life*ease;
      const dy = Math.sin(ang)*sp*life*ease - 30*k;
      drawHeart(x+dx, y+dy, r*(1+0.3*(1-k)));
      ctx.globalAlpha=1;
      if(k<1) requestAnimationFrame(anim);
    };
    requestAnimationFrame(anim);
  }
});
})();
</script>
</body>
</html>
